from math import pow, sqrtfrom heapq import heappop, heappush# CMPM 146: P2. Hanette Le and Matthew Tolentinodef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    src_dest = []    # A dictionary that maps boxes to (x,y) pair    detail_points = {}    curr_box = []    # box = (x1, x2, y1, y2)    # Find the boxes in which the source and destination are in    for box in mesh.get('boxes'):        # Get source box        if source_point[0] >= box[0] and source_point[0] <= box[1]:            if source_point[1] >= box[2] and source_point[1] <= box[3]:                curr_box = box                src_dest.insert(0, box)        # Get destination box        if destination_point[0] >= box[0] and destination_point[0] <= box[1]:            if destination_point[1] >= box[2] and destination_point[1] <= box[3]:                src_dest.append(box)    flag = False    # If a source box and destination box are found do a search    # Else print no path    if len(src_dest) > 1:        # Complete search algorithm (Breadth First Search)        # Fill dictionary with boxes set to False        visited = {}        for box in mesh.get('boxes'):            visited[box] = False        # Declare queue and path condition        queue = []                # Define source and destination        source = src_dest[0]        destination = src_dest[1]        # Add source to queue and set its visited to true        queue.append(source)        visited[source] = True        # Assign src and dest boxes with respective points        detail_points[source] = source_point        detail_points[destination] = destination_point        curr_x, curr_y = source_point[0], source_point[1]        while len(queue) != 0:            # Get current box and its neighbors            curr = queue.pop(0)            neighbors = mesh.get('adj')[curr]            # If the current box is the destination set path condition to true            if curr == destination:                flag = True            # Check if neighbors have been visited if not add them to queue and mark them as visited            # Compute new points from current point to destination box and add it to weight_points            for neigh in neighbors:                if visited[neigh] is False:                    newpoint = constrain_point(curr_x, curr_y, curr_box, neigh)                    curr_x, curr_y = newpoint[0], newpoint[1]                    curr_box = neigh                    queue.append(neigh)                    visited[neigh] = True        # Print based on path condition        if flag is True:            print('Path possible')        else:            print('No path possible')            return [], {}    else:        print('No path possible')        return [], {}    if flag is True:        # Get the box path using dijkstras or A*        # boxPath = dijkstras_shortest_path(src_dest[0], src_dest[1], mesh, weight_points)        boxPath = a_star(src_dest[0], src_dest[1], mesh, detail_points)        # Get the points along the box path using constrain_point function        points = []        newpoint = (0, 0)        startx, starty = source_point[0], source_point[1]        startbox = boxPath[0]        if len(boxPath) == 1:            points.append(((startx, starty), destination_point))        else:            for i in range(len(boxPath)-1):                newpoint = constrain_point(startx, starty, startbox, boxPath[i+1])                points.append(((startx, starty), newpoint))                startx, starty = newpoint[0], newpoint[1]                startbox = boxPath[i+1]            points.append((newpoint, destination_point))            # print("path:",path, "box key:",boxes.keys())        return points, boxPath        # return path, boxes.keys()def a_star(initial_position, destination, mesh, detail_points):    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    # The priority queue    queue = [(0, initial_position, destination), (1, destination, initial_position)]    # The dictionary that will be returned with the costs    distances = {}    distances[initial_position] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[initial_position] = None    # The dictionarys that track going from destination to initial point    back_dist = {}    back_dist[destination] = 0    back_prev = {}    back_prev[destination] = None    # flag to stop searching and variable to hold where paths cross    flag = False    midBox = None    while queue:        current_dist, current_node, curr_destination = heappop(queue)        # Check to see if search paths have crossed        if current_node in backpointers and curr_destination is initial_position:            flag = True            midBox = current_node            break        elif current_node in back_prev and curr_destination is destination:            flag = True            midBox = current_node            break        # Create list for neighboring boxes and weights        neighBoxes = []        neighbors = mesh.get('adj')[current_node]        # Get the weight to each neighbor from the current node        for neigh in neighbors:            curr_x, curr_y = detail_points[current_node]            newpoint = constrain_point(curr_x, curr_y, current_node, neigh)            weight = euclidean_distance((curr_x, curr_y), newpoint)            neighBoxes.append((neigh, weight))        # Calculate cost from current node to all the adjacent ones        if curr_destination is destination:            for adj_node, adj_node_cost in neighBoxes:                pathcost = current_dist + adj_node_cost                # If the cost is new                if adj_node not in distances or pathcost < distances[adj_node]:                    distances[adj_node] = pathcost                    backpointers[adj_node] = current_node                    curr_x, curr_y = close_point(detail_points[current_node], adj_node)                    detail_points[adj_node] = (curr_x,curr_y)                    priority = pathcost + euclidean_distance(detail_points[adj_node], destination)                    heappush(queue, (priority, adj_node, destination))        elif curr_destination is initial_position:            for adj_node, adj_node_cost in neighBoxes:                pathcost = current_dist + adj_node_cost                # If the cost is new                if adj_node not in back_prev or pathcost < back_dist[adj_node]:                    back_dist[adj_node] = pathcost                    back_prev[adj_node] = current_node                    curr_x, curr_y = close_point(detail_points[current_node], adj_node)                    detail_points[adj_node] = (curr_x, curr_y)                    priority = pathcost + euclidean_distance(detail_points[adj_node], initial_position)                    heappush(queue, (priority, adj_node, initial_position))        else:            print("Error: Invalid destination")    if flag is True:        # Path going to destination from source        forwardPath = [midBox]        back_node = backpointers[midBox]        while back_node is not None:            forwardPath.append(back_node)            back_node = backpointers[back_node]        # Path going to source from destination        backPath = []        back_node = back_prev[midBox]        while back_node is not None:            backPath.append(back_node)            back_node = back_prev[back_node]        # Return combined path from source to destination        return forwardPath[::-1] + backPath    else:        return Nonedef close_point(current, next):    cur_x, cur_y = current[0], current[1]    x1, x2, y1, y2 = next[0], next[1], next[2], next[3]    x = min(x2, max(x1, cur_x))    y = min(y2, max(y1, cur_y))    return x, ydef constrain_point(x, y, curbox, neigh):    # Get points of boxes    cur_x1, cur_x2, cur_y1, cur_y2 = curbox[0], curbox[1], curbox[2], curbox[3]    neigh_x1, neigh_x2, neigh_y1, neigh_y2 = neigh[0], neigh[1], neigh[2], neigh[3]    # Boundaries of x    min_x = max(cur_x1, neigh_x1)    max_x = min(cur_x2, neigh_x2)    # Boundaries of y    min_y = max(cur_y1, neigh_y1)    max_y = min(cur_y2, neigh_y2)    # Neighboring box is above or under    if min_y == max_y:        leftpoint = euclidean_distance([x,y],[min_x, min_y])        rightpoint = euclidean_distance([x,y],[max_x, min_y])        midpoint = euclidean_distance([x,y],[x, min_y])        # Added in midpoint constraints        if midpoint <= rightpoint and midpoint <= leftpoint and min_x < x < max_x:            return (x, min_y)        elif leftpoint <= rightpoint:            return (min_x, min_y)        else:            return (max_x, min_y)    # Neighboring box is left or right    if min_x == max_x:        downpoint = euclidean_distance([x,y],[min_x, min_y])        uppoint = euclidean_distance([x,y],[min_x, max_y])        midpoint = euclidean_distance([x,y],[min_x, y])        # Added in midpoint constraints        if midpoint <= downpoint and midpoint <= uppoint and min_y < y < max_y:            return (min_x, y)        elif downpoint <= uppoint:            return (min_x, min_y)        else:            return (min_x, max_y)    # We reached the last box    return (x,y)def euclidean_distance(point1, point2):    # Distance Formula    # ((x1-x2)^2 + (y1-y2)^2 )^0.5    distance = sqrt(pow((point1[0] - point2[0]), 2) + pow((point1[1] - point2[1]), 2))    return distance